# Chap04. Machine Language
#밑바닥부터만드는컴퓨터시스템


1-3장에서는 컴퓨터의 기초 구성요소에 필요한 ( 프로세서 , 메모리)를 불 논리 기반의 칩을 구현했다.
이번 장에서는 앞서 구현한 칩을 기계보다 사람에 조금 더 익숙한 언어로 조작하는 “기계어”를 다루는 방법에 대해 학습한다.

### 기계어와 어셈블리어
**기계어**는  기계가 해석가능한 언어이다. 따라서 기계의 설계자에 따라 해석이 다를수 있으며, 놀랍지도 않지만 당연하게도 0/1로만 구성된 언어이다.  놀랍게도 1-3장에서 0/1이 전부인 **불 논리**와 이들만의 연산인 **불 연산**을 도구로 컴퓨터의 기본 구성요소를 구현했다. 따라서 우리가 작성한 모든 명령어는 결국 컴퓨터를 위해 0/1로 변환된다.
**어셈블리어**는 다행히도 0/1만큼 열받는 언어는 아니다.  어셈블리어는 어셈블러를 통해 기계어로 변환 되며, SW 개발 목적으로 사용되는 고수준 언어(자바, 파이썬) 과는  하드웨어(cpu,memory,register) 조작을 위한 언어이다.
**따라서 0/1에 해당하는 규칙을 모두 외울 필요가 없다.** 어셈블리어서 정의한 **인터페이스**에 맞춰 작성한다면 최종적으로 0/1로 변환되어 ~기계어보다 쉽게 하드웨어를 조작할 수 있다.~ 
~~Java, Python 같은 고 수준의 언어를 먼저 접할수있는 시대에 태어난건 행운이다. 인공지능따위보다 기계어가 더 어렵다~~
 

> 다음은 폰노이만식 컴퓨터 플랫폼을 구성하기 위한 최소한의 하드웨어 요소들이다.  

### 메모리
- 컴퓨터에서 **데이터와 명령어를 저장**하는 하드웨어 장치.
- 저장을 위한 장치이므로 당 연 히 유일한 주소값이 존재한다.

### 프로세서
- 가장 친숙한 프로세서는 중앙 처리. 장치 (CPU)다.
- 기초 연산을 수행하는 장치이다.
- 기초 연산에는 산술 / 논리 / 메모리 접근 / 제어 혹은 분기 연산이 포함된다.

### 레지스터
- 메모리 접근 연산은 상대적으로 레지스터보다 느리다. ( Sol이 Key-Value 기반으로 키 기반 접근이 가능해서 메모리 보다 빠르다고 했다. 믿자. )
- 대부분의 프로세스는 값을 1개 저장할 수 있는 레지스터를 여러개 두고있다.
- 저장할수있는 용량은 메모리보다 작지만, 속도가 월등하므로 로컬 고속 메모리 역할을 한다.

### Hack 기계어
기계어와 어셈블리어간의 관계에 대해 대략적으로 이해했다면, 4장에서 Hack 기계어를 학습한뒤, 5장에서 Hack 기계어 기반 16BIT 컴퓨터를 설계?구현?하자.

### Hack 기계어 명세
- 폰 노이만 플랫폼이다.
- 메모리는 명령어 메모리 / 데이터 메모리 두 부분으로 분리되어있다.
	- 주소 공간중 MSB는 명령어(0) / 데이터(1) 구분을 위해 사용된다.
	- 따라서 주소 공간은 15BITS이다.
	- 명령어 메모리는 읽기 전용이다. ( 필요한 프로그램을 ROM 칩에 미리 기록 )
	- 핵의 CPU는 명령어 메모리에 존재하는 프로그램만 수행한단다.
	- 즉 미리 정의된 명령어만 수행가능하다. ( 읽기만 가능하니! )
- Hack에는 D, A라 불리는 16비트 레지스터가 각각 1개씩 딱 2개 있다.
	- D는 데이터 값을 저장하는 용도로만 사용된다.
	- A는 데이터 레지스터와 주소 레지스터라는 두 역할을 한다. 
- Hack 기계어에서 메모리 내 단어를 사용하고싶다면 답은 하나다
	- M을 써라.

> 기계어 조작법은 정교하게 정리하는것보다 이해를 바탕으로 머리속에 논리를 그릴수있는능력을 갖추는것이 중요하다고 생각한다.   
> 그리고 Hack 언어는저수준 언어인만큼 문법이 다양하지 않다.   
> 아래 코드 해석을 통해 Hack 기계어에 익숙해지자.    


## 강점이 단점으로 퇴색되는 일이 없도록 하자
- 바쁘고 정신없다보니 컴퓨터 시스템에 대한 이해보다 구현 그 자체에 더 집중한것같다. 
- 지금 직무가 직무인지라.. 로직을 구현하는것이 너무 재미있었나보다. (변명)
- 이 책에 대한 학습이 마무리 될때쯤, SW 부터 HW까지 컴퓨터 플랫폼의 전반적인 구성요소에 대한 지식인으로 거듭나길~! 


## Mult.asm
- num1 * num2 은 num1 + num1 + ... (n번) 과 동일하다.
```nasm
@i
M=1
@R2
M=0
(LOOP)
    @i
    D=M
    @R1
    D=D-M
    @END
    D;JGT
    @R0
    D=M
    @R2
    M=D+M
    @i
    M=M+1
    @LOOP
    0;JMP
(END)
@END
0;JMP

```

## Fill.asm
- 뿌듯.
```nasm

@SCREEN 
D=A

@TARGET // BLACK OR WHITE TARGET IDX (Memory ADDRESS)
M=D

@R3 // SCREEN의 MIN ADDRESS
M=D

@KBD
D=A

@R4 // SCREEN의 MAX ADDRESS
M=D-1


(LOOP)
@KBD
D=M   
// M=0 
// (^오^)->  FillAutoMatic.tst로 테스트 시 , M=0 주석 해제할 것.

@BLACK
D;JGT

@WHITE
D;JEQ    

(BLACK)
    @TARGET
    D=M
    A=M
    M=-1
    
    @R4     // Check Memory Idx ( R4 : SCREEN의 MAX ADDRESS )
    D=D-M
    @LOOP
    D;JEQ

    @TARGET // ++NEXT TARGET
    M=M+1
    @LOOP    
    0;JMP


(WHITE)
    @TARGET
    D=M
    A=M
    M=0
    
    @R3     // Check Memory Idx ( R3 : SCREEN의 MIN ADDRESS )
    D=D-M
    @LOOP
    D;JEQ
    
    @TARGET // --NEXT TARGET
    M=M-1
    @LOOP
    0;JMP

@LOOP 
0;JMP

```